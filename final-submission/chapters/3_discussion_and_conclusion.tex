% !TeX spellcheck = en_GB
\chapter{Discussion and Conclusion}
\label{sec:discussion-and-conclusion}
% TODO: Write this paragraph in past tense or present perfect

% TODO: Rephrase, this paragraph was copied from https://eprints.hsr.ch/523/1/Data%20over%20DAB.pdf !
This chapter contains our conclusion to our decisions, our lapses and the whole project.

\section{Achieved Result}
% What is the result of this study project?
% - Specification
% - Minimal working prototype
% - Not production ready but works stable
% discuss the validity of the new proposal
% compare with (papers) problems addressed in the background section
% Discuss (performance) measurements

\section{Lessons Learned}
% Describe what worked well and what went wrong (Lapses)
% What took us time?
% Summarize issues discussed in the retros

In this section, we describe unexpected project events and the lessons we learned from them.

\subsection{Project course}
\subsubsection{Documentation}
While discussing the documentation efforts in mini-retrospective two, we noted that some terms like metadata or chunks were not defined unambiguously and therefore used for different concepts in varying contexts. To standardise these, we decided to introduce a glossary that uniquely and precisely defines each of these terms.

While elaborating the architecture, we started researching advanced data distribution mechanisms and consensus algorithms. We were both very interested in these topics, but after a discussion with Prof.~Mehta and retrospective one, we realised that the time frame of the study project would not suffice to realise such advanced algorithms.

We frequently underestimated the documentation efforts, particularly the time required for reviewing. We responded by estimating more time and increase the risk reserve time for documentation issues. Besides, we also agreed we would stop and reassess earlier on issues that took longer than expected.

\subsubsection{Rust Formatting and Documentation}
During retrospective two, we noted that the source code was not fully formatted according to the Rust Style Guide\footnote{https://github.com/rust-lang-nursery/fmt-rfcs/blob/master/guide/guide.md} and that the source code documentation was not complete. To ensure a consistent code formatting, we added the RustFmt\footnote{https://github.com/rust-lang-nursery/rustfmt\#rustfmt---} tool as acceptance criterion to our Definition of Done \cite{project-plan} and created a task to complete the documentation.

\subsubsection{Project management}
During the first mini-retrospective and first full retrospective, we discussed several small improvements regarding the task management and how, respectively, where we would work together. During the second sprint, we also neglected to plan time for the supervision meetings and infrastructure updates, which we met by creating a checklist for sprint planning.

A month into the project during the second mini-retrospective, we agreed that we should create more issues with shorter running times and make sure that we reviewed issues as soon as possible. Also, the reported working hours were incomplete and only narrowly fulfilled the planned sprint goals. Therefore, we decided to log the working hours more precisely and intensify the work efforts.


\subsection{Decisions}
\subsubsection{Redundancy: \gls{system-m-replication}}
For the prototype, we decided to implement a \gls{system-m-replication} replication. This decision worked out as we expected and allowed us to create a straightforward yet efficient way to replicate \glspl{chunk}.

\subsubsection{Programming Language and Ecosystem}
During the language evaluation, we decided for using Rust to implement the prototype (See \fullref{sec:language-evaluation} for details on this decision).

While we still think, that Rust is the right choice for the implementation of a backup application as presented in this report, we would have been more productive with a language we already had experience in, like Python or Java. For a prototype, these languages would also have sufficed, despite possibly not being as stable and fast as a Rust implementation.

\subsubsection{Frameworks: Tokio and Diesel}
As discussed in Chapter \fullref{sec:our-approach}, we utilised the Tokio and Diesel frameworks. While offering an advanced feature set considered the relative young Rust environment, we found that the documentation for both frameworks was not sufficiently comprehensible.

Also, the Diesel framework offers an insufficient set of type implementations for SQLite and lacks extensibility e.g.~adding support for timezone timestamps.

\subsubsection{Storage: Database with SQLite}
As we started implementing the prototype, using SQLite seemed an obvious choice, as it is both easy to use and lightweight.

This decision turned out to be suboptimal, as SQLite is not very well suited for concurrent write access \cite{sqlite-locking} and offers an insufficient set of data types \cite{sqlite-datatypes}. For example, SQLite only allows signed 32-bit integers to be used as record identifiers, which effectively limits the number of \glspl{file}, folders or \glspl{chunk} to $2^{31}-1$ each in the prototype.

As a result of the combined difficulties with Diesel and SQLite, we spent considerably more time implementing the database access than initially planned.

In hindsight, we should have further evaluated other database systems including an in-memory database for the \gls{client}.

\section{Future work}
% How to procede?
% pointing out new research lines

\section{Conclusion}
% Final Conclusion - are we happy, did we expect more,...

